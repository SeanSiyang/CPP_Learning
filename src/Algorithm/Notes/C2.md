# 变量取值范围

- 整型：```int```、```long long```
- 浮点型：```float```、```double```

## 整型

```int``` 占用 **32bit**，即 4Byte
取值范围：$-2^{31}$ 到 $(2^{31}-1)$
大致范围：$-2\times 10^{9}$ 到 $2\times10^{9}$

绝对值在$10^9$范围以内的整数都可以定义为int

```long long``` 占用 **64bit**，8Byte
取值范围：$-2^{63}$ 到 $(2^{63}-1)$
大致范围：$-9\times 10^{18}$ 到 $9\times10^{18}$

整数取值范围超过 2147483647 需要使用```long long```

初始化时，需要在最后加上```LL```
```c++
long long big_num;
long long big_num = 123456789012345LL;
```

使用 ```unsigned``` 表示无符号数，占用的位数和原先相同，把负数范围挪到正数上

```unsigned int``` 的范围是 0 到 $(2^{32}-1)$
```unsigned long long```的范围是 0 到 $(2^{64}-1)$

题目要求 $10^9$ 以内或 **32位整数** --> ```int```
若是$10^{18}$以内或 **64位整数** --> ```long long```

```%d```是int型的输出格式

## 浮点型

```float``` 占用 32bit，其中1bit为符号位，8bit为指数位，23bit为尾数位

有效精度 6 到 7 位

```double``` 占用 64bit
有效精度 15~16位

```%f```是float和double型的输出格式

对于浮点数，都使用double

## 字符型

- 字符变量和字符常量
- 转义字符
- 字符串常量


标准ASCII码范围是 0 到 127

小写字母比大写字母的ASCII码值大32

0~9 --> 48~57
A~Z --> 65~90
a~z --> 97~122

字符常量必须用**单引号**标注起来，以区分是作为字符变量还是字符常量出现

字符就是按ASCII码存储的，```%c```是char型的输出格式

常用的两个转义字符：
- ```\n``` 表示**换行**
- ```\0``` 表示**空字符NULL**，ASCII码为 0 

字符串常量可以作为初值赋值给字符数组，输出使用```%s```格式

```c++
#include <stdio.h>

int main()
{
    char str1[25] = "Wo ai de ren bu ai wo";
    char str2[25] = "so sad a story it is.";
    printf("%s, %s", str1, str2);

    return 0;
}
```
str1和str2都是字符数组，不可以把字符串常量赋值给字符变量


## 布尔型

取值为 true（非0） 和 false（0）

在**赋值**时，可以使用**true或false**赋值，也可以使用**整型常量**进行赋值。整型常量赋值给布尔变量时，会自动转换为 true 和 false

赋值或判断的时候认为非0为 true，0 为 false
但是当以布尔变量进行**存储**，并以%d格式输出布尔变量时，true为 1，false为 0

表达式的结果也是一样的，只要发生了存储，就是 1 或 0

# 强制转换

需求：
- 把浮点数的小数部分切掉
- 避免整数除以整数视为整除操作

```c++
#include <stdio.h>

int main() 
{
    double r = 12.56;
    int a = 3, b = 5;
    printf("%d\n", (int)r);
    printf("%d\n", a / b);
    printf("%.1f", (double)a / (double)b);
    
    return 0;
}
```

# 宏定义和const常量

宏定义：用一个标识符来替代常量

```c++
#define 标识符 常量
```

例子：
```c++
#include <stdio.h>
#define pi 3.14

int main()
{
    double r = 3;
    printf("%f\n", pi * r * r);

    return 0;
}
```

const常量：
```c++
const 数据类型 变量名 = 常量;
```

例子：
```c++
#include <stdio.h>
const double pi = 3.14;

int main()
{
    double r = 3;
    printf("%f\n", pi * r * 2);

    return 0;
}
```

define 可以定义常量，也可以定义任何语句或片段
```c++
#define 标识符 任何语句或片段
```

例子：
```c++
#include <stdio.h>
#define ADD(a, b) ((a) + (b))

int main()
{
    int num1 = 3, num2 = 5;
    printf("%d", ADD(num1, num2));

    return 0;
}
```

不要使用宏定义来做除了定义常量以外的事情，除非都加上括号

# 运算符

出现问题时，优先考虑是不是分母为 0

逻辑运算符：
与 && 
或 ||
非 !

三目运算符：
```c++
A ? B : C;
```


两个数中取较大值：
```c++
#include <stdio.h>
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int main()
{
    int a = 4, b = 3;
    printf("%d\n", MAX(a, b));
    return 0;
}
```

位运算符：

int型的无穷大的数INF可以设置为 ```(1<<31)-1```

位运算符的优先级低于算术运算符

常用INF设置：

```c++
const int INF = (1 << 30) - 1;
const int INF = 0x3fffffff;
```

# 顺序结构

## scanf

```c++
scanf("%d", &n); // int
scanf("%lld", &n); // long long
scanf("%f", &n); // float
scanf("%lf", &n); // double
scanf("%c", &n); // char
scanf("%s", n); // char[]
```

数组不需要取地址，因为数组名代表了数组中第一个元素的地址

除了char数组，其他变量类型都需要取地址符

输入若有特殊格式要求：
比如：hh:mm:ss
```c++
int hh, mm, ss;
scanf("%d:%d:%d", &hh, &mm, &ss);
```

scanf双引号内的内容就是整个输入，把数据换成它们对应的格式符并把变量的地址按次序写在后面

```c++
int a;
double b;
char c;
scanf("%d, %lf, %c", &a, &b, &c);
```

若输入用空格隔开的两个数字，两个```%d```之间可以**不加空格**
除了```%c```，scanf对其他格式符的输入是以**空白符 比如：空格、Tab、换行**为结束判断标志

字符数组使用```%s```读入时，以**空格**或**换行**作为读入结束的标志
```c++
#include <stdio.h>

int main()
{
    char str[10];
    scanf("%s", str);
    printf("%s", str);

    return 0;
}
```
scanf可以使用```%c```读取**空格**或**换行**

```c++
#include <stdio.h>

int main()
{
    int a;
    char c, str[10];
    scanf("%d%c%s", &a, &c, str);
    printf("a=%d, c=%c, str=%s", a, c, str);
    return 0;
}
```

如果输入数据后程序异常退出，考虑是否遗漏取地址符

## printf

```c++
printf("%d", n);
printf("%lld", n);
printf("%f", fl);
printf("%f", db);
printf("%c", c);
printf("%s", str);
```

对于double类型，输出格式为```%f```，输入格式是```%lf```

三种实用的输出格式：
```%md```使不足m位的int型变量以m位进行右对齐输出，高位用空格补齐，若超过m位，维持原样
```%0md```用0补齐
```%.mf```让浮点数**保留m位小数**或**精确到小数点后XX位**
如果需要四舍五入，则需要使用round函数

## getchar & putchar

getchar可以识别换行符，会存储换行符

# typedef

给复杂的数据类型起别名

```c++
#include <stdio.h>

typedef long long LL;

int main()
{
    LL a = 123456789012345, b = 234567890123456;
    printf("%lld\n", a + b);
    return 0;
}
```

# 常用math函数

需要头文件：```#include <math.h>```

fabs 对 double 取绝对值
abs 对 int 取绝对值

floor 对double向下取整
ceil 对double向上取值

pow：返回$r^p$，r和p都是double
```c++
#include <stdio.h>
#include <math.h>

int main()
{
    double db = pow(2.0, 3.0);
    printf("%f\n", db);

    return 0;
}
```

sqrt：对 double 进行算术平方根
log：返回double变量的以自然对数为底的对数 $\log_{e}{b}$

对任意底数求对数，需要使用换底公式
>若$a^b=N(a>0, a \not ={1})$ ，b叫做以a为底N的对数，记作：$b=\log_aN$

sin：double变量的正弦值
cos：double变量的余弦值
tan：double变量的正切值

参数需要是弧度制

pi的精确值：
```c++
const double pi = acos(-1.0);
```

例子：
```c++
#include <stdio.h>
#include <math.h>

const double pi = acos(-1.0);

int main()
{
    double db1 = sin(pi * 45 / 180);
    double db2 = cos(pi * 45 / 180);
    double db3 = tan(pi * 45 / 180);

    printf("%f, %f, %f\n", db1, db2, db3);
    return 0;
}
```

asin：double变量的反正弦值
acos：double变量的反余弦值
atan：double变量的反正切值
round：对double变量四舍五入，结果会进行取整

# 选择结构

技巧：如果表达式是```!=0```，可以省略```!=0```

```c++
#include <stdio.h>

int main()
{
    int n = 0, m = 5;
    if (n) 
    {
        printf("n is not zero!\n");
    }
    else
    {
        printf("n is zero!\n");
    }

    if (m)
    {
        printf("m is not zero!\n");
    }
    else
    {
        printf("m is zero!\n");
    }
}
```

技巧：如果表达式是```==0```，可以省略```==0```，在表达式前添加非运算符 ```!```

```c++
#include <stdio.h>

int main()
{
    int n = 0, m = 5;
    if (!n)
    {
        printf("n is zero!\n");
    }
    else
    {
        printf("n is not zero!\n");
    }

    if (!m)
    {
        printf("n is zero!\n");
    }
    else
    {
        printf("n is not zero!\n");
    }
}
```

# 循环结构

1 + 2 + ... + 100
```c++
#include <stdio.h>

int main()
{
    int n = 1, sum = 0;
    while (n <= 100)
    {
        sum += n;
        n++;
    }

    printf("sum = %d\n", sum);
    return 0;
}
```

while条件判断同样适用前面的两个技巧
- 如果表达式是```!=0```，可以省略```!=0```
- 如果表达式是```==0```，可以省略```==0```，并在表达式前添加非运算符```!```

将一个数字的每一位数字进行相加
```c++
#include <stdio.h>

int main()
{
    int n = 12345, count = 0;
    while (n)
    {
        count = count + n % 10;
        n = n / 10;
    }
    printf("%d\n", count);

    return 0;
}
```
```n % 10```：获取当前n的最低位
```n = n / 10```：将最低位抹去

```c++
#include <stdio.h>

int main()
{
    int n = 1, sum = 0;
    do {
        sum = sum + n;
        n++;
    } while (n <= 100)

    printf("sum = %d\n", sum);
    return 0;
}
```

对输入的非负整数n，输出n个1
```c++
#include <stdio.h>

int main()
{
    int n;
    scanf("%d", &n);

    while (n > 0)
    {
        printf("1");
        n--;
    }

    return 0;
}
```

break：在需要的场合下直接退出循环
continue：在需要的地方临时结束循环的当前轮回，然后进入下一个轮回

判断一个数字为奇数：```i % 2 == 1```

偶数相加：
```c++
#include <stdio.h>

int main()
{
    int sum = 0;
    for (int i = 0; i <= 5; i++)
    {
        if (i % 2 == 1) continue;
        sum += i;
    }
    printf("sum = %d\n", sum);

    return 0;
}
```

# 数组

数组是从某个地址开始连续多个位置形成的元素集合

数组大小必须是整型变量，**不可以是变量**

一维数组的定义：
```数据类型 数组名[数组大小]```

```c++
int a[10];
double db[2333];
char str[100000];
bool HashTable[1000000];
```

访问数组元素：
```数组名词[下标]```

数组的初始化：
```c++
#include <stdio.h>

int main()
{
    int a[10] = {5, 3, 2, 6, 8, 4};
    for (int i = 0; i < 10; i++)
    {
        printf("a[%d] = %d\n", i, a[i]);
    }

    return 0;
}
```

如果没有初始化，则可能是随机值

如果想要给整个数组赋初值0：
- 把第一个元素赋值为0
- 只用一个大括号来表示

```c++
int a[10] = {};   
int a[10] = { 0 };
```

递推：根据一些条件，不断让后一位的结果由前一位或前若干位计算得到

分为顺推和递推，顺推是将数组中后续元素都赋值为其前一个元素的两倍的功能

```c++
#include <stdio.h>

int main()
{
    // 递推之顺推
    int a[10];
    scanf("%d", &a[0]);

    for (int i = 1; i < 10; i++)
    {
        a[i] = a[i - 1] * 2;
    }

    for (int i = 0; i < 10; i++)
    {
        printf("a[%d] = %d\n", i, a[i]);
    }

    return 0;
}
```

# 冒泡排序

交换两个数：

```c++
#include <stdio.h>

int main()
{
    int a = 1, b = 2;
    int temp = a;
    a = b;
    b = temp;

    printf("a = %d, b = %d\n", a, b);

    return 0;
}
```

整个过程执行n-1趟，每一趟从左到右依次比较相邻的两个数，如果大的数在左边，则交换两个数，该趟结束时，该趟最大数被移动到当前剩余数的最右边

```c++
#include <stdio.h>

int main()
{
    int a[10] = {3, 1, 4, 5, 2};
    for (int i = 1; i <= 4; i++) // 控制轮数
    {
        for (int j = 0; j < 5 - i; j++) // 每完成一轮，都少一个需要比较的数字
        {
            if (a[j] > a[j + 1])
            {
                int temp = a[j + 1];
                a[j + 1] = a[j];
                a[j] = temp;
            }
        }
    }

    for (int i = 0; i < 5; i++)
    {
        printf("%d ", a[i]);
    }

    return 0;
}
```

规律是当第i趟时（i从1开始），从a[0]到a[n-i-1]都需要与各自的下一个数比较。

# 二维数组

```c++


```