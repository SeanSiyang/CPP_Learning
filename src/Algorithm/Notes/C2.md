# 变量取值范围

- 整型：```int```、```long long```
- 浮点型：```float```、```double```

## 整型

```int``` 占用 **32bit**，即 4Byte
取值范围：$-2^{31}$ 到 $(2^{31}-1)$
大致范围：$-2\times 10^{9}$ 到 $2\times10^{9}$

绝对值在$10^9$范围以内的整数都可以定义为int

```long long``` 占用 **64bit**，8Byte
取值范围：$-2^{63}$ 到 $(2^{63}-1)$
大致范围：$-9\times 10^{18}$ 到 $9\times10^{18}$

整数取值范围超过 2147483647 需要使用```long long```

初始化时，需要在最后加上```LL```
```c++
long long big_num;
long long big_num = 123456789012345LL;
```

使用 ```unsigned``` 表示无符号数，占用的位数和原先相同，把负数范围挪到正数上

```unsigned int``` 的范围是 0 到 $(2^{32}-1)$
```unsigned long long```的范围是 0 到 $(2^{64}-1)$

题目要求 $10^9$ 以内或 **32位整数** --> ```int```
若是$10^{18}$以内或 **64位整数** --> ```long long```

```%d```是int型的输出格式

## 浮点型

```float``` 占用 32bit，其中1bit为符号位，8bit为指数位，23bit为尾数位

有效精度 6 到 7 位

```double``` 占用 64bit
有效精度 15~16位

```%f```是float和double型的输出格式

对于浮点数，都使用double

## 字符型

- 字符变量和字符常量
- 转义字符
- 字符串常量


标准ASCII码范围是 0 到 127

小写字母比大写字母的ASCII码值大32

0~9 --> 48~57
A~Z --> 65~90
a~z --> 97~122

字符常量必须用**单引号**标注起来，以区分是作为字符变量还是字符常量出现

字符就是按ASCII码存储的，```%c```是char型的输出格式

常用的两个转义字符：
- ```\n``` 表示**换行**
- ```\0``` 表示**空字符NULL**，ASCII码为 0 

字符串常量可以作为初值赋值给字符数组，输出使用```%s```格式

```c++
#include <stdio.h>

int main()
{
    char str1[25] = "Wo ai de ren bu ai wo";
    char str2[25] = "so sad a story it is.";
    printf("%s, %s", str1, str2);

    return 0;
}
```
str1和str2都是字符数组，不可以把字符串常量赋值给字符变量


## 布尔型

取值为 true（非0） 和 false（0）

在**赋值**时，可以使用**true或false**赋值，也可以使用**整型常量**进行赋值。整型常量赋值给布尔变量时，会自动转换为 true 和 false

赋值或判断的时候认为非0为 true，0 为 false
但是当以布尔变量进行**存储**，并以%d格式输出布尔变量时，true为 1，false为 0

表达式的结果也是一样的，只要发生了存储，就是 1 或 0

# 强制转换

需求：
- 把浮点数的小数部分切掉
- 避免整数除以整数视为整除操作

```c++
#include <stdio.h>

int main() 
{
    double r = 12.56;
    int a = 3, b = 5;
    printf("%d\n", (int)r);
    printf("%d\n", a / b);
    printf("%.1f", (double)a / (double)b);
    
    return 0;
}
```

# 宏定义和const常量

宏定义：用一个标识符来替代常量

```c++
#define 标识符 常量
```

例子：
```c++
#include <stdio.h>
#define pi 3.14

int main()
{
    double r = 3;
    printf("%f\n", pi * r * r);

    return 0;
}
```

const常量：
```c++
const 数据类型 变量名 = 常量;
```

例子：
```c++
#include <stdio.h>
const double pi = 3.14;

int main()
{
    double r = 3;
    printf("%f\n", pi * r * 2);

    return 0;
}
```

define 可以定义常量，也可以定义任何语句或片段
```c++
#define 标识符 任何语句或片段
```

例子：
```c++
#include <stdio.h>
#define ADD(a, b) ((a) + (b))

int main()
{
    int num1 = 3, num2 = 5;
    printf("%d", ADD(num1, num2));

    return 0;
}
```

不要使用宏定义来做除了定义常量以外的事情，除非都加上括号

# 运算符

出现问题时，优先考虑是不是分母为 0

逻辑运算符：
与 && 
或 ||
非 !

三目运算符：
```c++
A ? B : C;
```


两个数中取较大值：
```c++
#include <stdio.h>
#define MAX(a, b) ((a) > (b) ? (a) : (b))

int main()
{
    int a = 4, b = 3;
    printf("%d\n", MAX(a, b));
    return 0;
}
```

位运算符：

int型的无穷大的数INF可以设置为 ```(1<<31)-1```

位运算符的优先级低于算术运算符

常用INF设置：

```c++
const int INF = (1 << 30) - 1;
const int INF = 0x3fffffff;
```

# 顺序结构

## scanf

```c++
scanf("%d", &n); // int
scanf("%lld", &n); // long long
scanf("%f", &n); // float
scanf("%lf", &n); // double
scanf("%c", &n); // char
scanf("%s", n); // char[]
```

数组不需要取地址，因为数组名代表了数组中第一个元素的地址

除了char数组，其他变量类型都需要取地址符

输入若有特殊格式要求：
比如：hh:mm:ss
```c++
int hh, mm, ss;
scanf("%d:%d:%d", &hh, &mm, &ss);
```

scanf双引号内的内容就是整个输入，把数据换成它们对应的格式符并把变量的地址按次序写在后面

```c++
int a;
double b;
char c;
scanf("%d, %lf, %c", &a, &b, &c);
```

若输入用空格隔开的两个数字，两个```%d```之间可以**不加空格**
除了```%c```，scanf 对其他格式符的输入是以**空白符**为结束判断标志，比如：空格、Tab、换行

> %c 会读取空格或换行

字符数组使用```%s```读入时，以**空格**或**换行**作为读入结束的标志
```c++
#include <stdio.h>

int main()
{
    char str[10];
    scanf("%s", str);
    printf("%s", str);

    return 0;
}
```
scanf可以使用```%c```读取**空格**或**换行**

```c++
#include <stdio.h>

int main()
{
    int a;
    char c, str[10];
    scanf("%d%c%s", &a, &c, str);
    printf("a=%d, c=%c, str=%s", a, c, str);
    return 0;
}
```

如果输入数据后程序异常退出，考虑是否遗漏取地址符

## printf

```c++
printf("%d", n);
printf("%lld", n);
printf("%f", fl);
printf("%f", db);
printf("%c", c);
printf("%s", str);
```

对于double类型，输出格式为```%f```，输入格式是```%lf```

三种实用的输出格式：
```%md```使不足m位的int型变量以m位进行右对齐输出，高位用空格补齐，若超过m位，维持原样
```%0md```用0补齐
```%.mf```让浮点数**保留m位小数**或**精确到小数点后XX位**
如果需要四舍五入，则需要使用round函数

## getchar & putchar

getchar可以识别换行符，会存储换行符

# typedef

给复杂的数据类型起别名

```c++
#include <stdio.h>

typedef long long LL;

int main()
{
    LL a = 123456789012345, b = 234567890123456;
    printf("%lld\n", a + b);
    return 0;
}
```

# 常用math函数

需要头文件：```#include <math.h>```

fabs 对 double 取绝对值
abs 对 int 取绝对值

floor 对double向下取整
ceil 对double向上取值

pow：返回$r^p$，r和p都是double
```c++
#include <stdio.h>
#include <math.h>

int main()
{
    double db = pow(2.0, 3.0);
    printf("%f\n", db);

    return 0;
}
```

sqrt：对 double 进行算术平方根
log：返回double变量的以自然对数为底的对数 $\log_{e}{b}$

对任意底数求对数，需要使用换底公式
>若$a^b=N(a>0, a \not ={1})$ ，b叫做以a为底N的对数，记作：$b=\log_aN$

sin：double变量的正弦值
cos：double变量的余弦值
tan：double变量的正切值

参数需要是弧度制

pi的精确值：
```c++
const double pi = acos(-1.0);
```

例子：
```c++
#include <stdio.h>
#include <math.h>

const double pi = acos(-1.0);

int main()
{
    double db1 = sin(pi * 45 / 180);
    double db2 = cos(pi * 45 / 180);
    double db3 = tan(pi * 45 / 180);

    printf("%f, %f, %f\n", db1, db2, db3);
    return 0;
}
```

asin：double变量的反正弦值
acos：double变量的反余弦值
atan：double变量的反正切值
round：对double变量四舍五入，结果会进行取整

# 选择结构

技巧：如果表达式是```!=0```，可以省略```!=0```

```c++
#include <stdio.h>

int main()
{
    int n = 0, m = 5;
    if (n) 
    {
        printf("n is not zero!\n");
    }
    else
    {
        printf("n is zero!\n");
    }

    if (m)
    {
        printf("m is not zero!\n");
    }
    else
    {
        printf("m is zero!\n");
    }
}
```

技巧：如果表达式是```==0```，可以省略```==0```，在表达式前添加非运算符 ```!```

```c++
#include <stdio.h>

int main()
{
    int n = 0, m = 5;
    if (!n)
    {
        printf("n is zero!\n");
    }
    else
    {
        printf("n is not zero!\n");
    }

    if (!m)
    {
        printf("n is zero!\n");
    }
    else
    {
        printf("n is not zero!\n");
    }
}
```

# 循环结构

1 + 2 + ... + 100
```c++
#include <stdio.h>

int main()
{
    int n = 1, sum = 0;
    while (n <= 100)
    {
        sum += n;
        n++;
    }

    printf("sum = %d\n", sum);
    return 0;
}
```

while条件判断同样适用前面的两个技巧
- 如果表达式是```!=0```，可以省略```!=0```
- 如果表达式是```==0```，可以省略```==0```，并在表达式前添加非运算符```!```

将一个数字的每一位数字进行相加
```c++
#include <stdio.h>

int main()
{
    int n = 12345, count = 0;
    while (n)
    {
        count = count + n % 10;
        n = n / 10;
    }
    printf("%d\n", count);

    return 0;
}
```
```n % 10```：获取当前n的最低位
```n = n / 10```：将最低位抹去

```c++
#include <stdio.h>

int main()
{
    int n = 1, sum = 0;
    do {
        sum = sum + n;
        n++;
    } while (n <= 100)

    printf("sum = %d\n", sum);
    return 0;
}
```

对输入的非负整数n，输出n个1
```c++
#include <stdio.h>

int main()
{
    int n;
    scanf("%d", &n);

    while (n > 0)
    {
        printf("1");
        n--;
    }

    return 0;
}
```

break：在需要的场合下直接退出循环
continue：在需要的地方临时结束循环的当前轮回，然后进入下一个轮回

判断一个数字为奇数：```i % 2 == 1```

偶数相加：
```c++
#include <stdio.h>

int main()
{
    int sum = 0;
    for (int i = 0; i <= 5; i++)
    {
        if (i % 2 == 1) continue;
        sum += i;
    }
    printf("sum = %d\n", sum);

    return 0;
}
```

# 数组

数组是从某个地址开始连续多个位置形成的元素集合

数组大小必须是整型常量，**不可以是变量**

下面这种形式会报错：
```c++
int n = 10;
int nums[n];
```

一维数组的定义：
```数据类型 数组名[数组大小]```

```c++
int a[10];
double db[2333];
char str[100000];
bool HashTable[1000000];
```

访问数组元素：
```数组名词[下标]```

数组的初始化：
```c++
#include <stdio.h>

int main()
{
    // 前六个元素被赋初值，后面没有被赋值的值都为 0
    int a[10] = {5, 3, 2, 6, 8, 4};
    for (int i = 0; i < 10; i++)
    {
        printf("a[%d] = %d\n", i, a[i]);
    }

    return 0;
}
```

如果没有初始化，则可能是随机值

如果想要给整个数组赋初值 0：
- 把第一个元素赋值为 0
- 只用一个大括号来表示

```c++
int a[10] = {};   
int a[10] = { 0 };
```

递推：根据一些条件，不断让后一位的结果由前一位或前若干位计算得到

分为**顺推**和**递推**

顺推的一个例子是将数组中后续元素都赋值为其前一个元素的两倍

```c++
#include <stdio.h>

int main()
{
    // 递推之顺推
    int a[10];
    scanf("%d", &a[0]);

    for (int i = 1; i < 10; i++)
    {
        a[i] = a[i - 1] * 2;
    }

    for (int i = 0; i < 10; i++)
    {
        printf("a[%d] = %d\n", i, a[i]);
    }

    return 0;
}
```

# 冒泡排序

排序：将一个无序序列按某个规则进行有序排列

思想：每次通过交换的方式把当前**剩余元素**的最大值移动到一端，而当剩余元素减少为 0 时，排序结束。

交换两个数：

```c++
#include <stdio.h>

int main()
{
    int a = 1, b = 2;
    int temp = a;
    a = b;
    b = temp;

    printf("a = %d, b = %d\n", a, b);

    return 0;
}
```

整个过程执行**n-1趟**，每一趟从左到右依次比较相邻的两个数，如果大的数在左边，则交换两个数，该趟结束时，该趟最大数被移动到当前剩余数的最右边

```c++
#include <stdio.h>

int main()
{
    int a[10] = {3, 1, 4, 5, 2};
    for (int i = 1; i <= 4; i++) // 一共 n-1 轮
    {
        for (int j = 0; j < 5 - i; j++) // 5-i 是因为用于比较的数到了倒数第二个就可以了，在循环中会 j+1 来获取下一个，同时每结束一轮，就会少一个需要比较的数，i 就可以控制数量
        {
            if (a[j] > a[j + 1])
            {
                int temp = a[j + 1];
                a[j + 1] = a[j];
                a[j] = temp;
            }
        }
    }

    for (int i = 0; i < 5; i++)
    {
        printf("%d ", a[i]);
    }

    return 0;
}
```

规律是当第i趟时（i从1开始），从a[0]到a[n-i-1]都需要与各自的下一个数比较。

比如数组有5个元素，
第1趟，那需要与下一个数进行比较的是 a[0] 到 a[5-1-1] 也就是a[0] 到 a[3] 

# 二维数组

初始化二维数组时，需要按第一维的顺序依次用大括号给出第二维初始化情况，然后将它们用逗号分隔，并用大括号全部括住，没有被指定值的部分被默认为 0

无论是对一维数组还是二维数组，使用空的大括号，都代表全部赋值为 0

```c++
#include <stdio.h>
int main() 
{
    int a[5][6] = {{3, 1, 2}, {8, 4}, {}, {1, 2, 3, 4, 5}};
    for (int i = 0; i < 5; i++)
    {
        for (int j = 0; j < 6; j++)
        {
            printf("%d", a[i][j]);
        }
        printf("\n");
    }

    return 0;
}
```

给二维数组赋值：
```c++
#include <stdio.h>

int main()
{
    int a[3][3], b[3][3];
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            scanf("%d", &a[i][j]);
        }
        
    }
        
}
```

如果数组大小较大，比如$10^6$，需将其定义在主函数外面，否则程序会异常退出

函数内部申请的局部变量存储在**系统栈**中，可以申请的空间较小

函数外部申请的全局变量存储在**静态存储区**，可以申请的空间较大

```c++
#include <stdio.h>

int a[1000000];

int main()
{
    for (int i = 0; i < 1000000; i++)
    {
        a[i] = i;
    }

    return 0;
}
```

# 给数组中每个元素赋相同的值
- ```memset```函数
- ```fill```函数

memset：
```c++
memset(数组名, 值, sizeof(数组名))
```
需要头文件：```string.h```

适用于给数组中每个元素赋值为 0 或 -1

```c++
#include <stdio.h>
#include <string.h>

int main()
{
    int a[5] = {1, 2, 3, 4, 5};
    memset(a, 0, sizeof(a));

    for (int i = 0; i < 5; i++)
    {
        printf("%d ", a[i]);
    }

    printf("\n");

    memset(a, -1, sizeof(a));
    for (int i = 0; i < 5; i++)
    {
        printf("%d ", a[i]);
    }
    printf("\n");

    return 0;
}
```

同理也可以给二维数组所有元素赋值：
```c++
int b[5][5] = {};
memset(b, -1, sizeof(b));

for (int i = 0; i < 5; i++)
{
    for (int j = 0; j < 5; j++)
    {
        printf("%d ", b[i][j]);
    }
}
printf("\n");
```

如果要给数组所有元素赋其他值，使用```fill```函数

# 字符数组

字符数组的初始化方式类似于数组，而且可以直接通过字符串来初始化

> 只能初始化，不能直接使用字符串赋值字符数组

```c++
#include <stdio.h>

int main()
{
    char str[15] = {'G', 'o', 'o', 'd', ' ', 's', 't', 'o', 'r', 'y', '!'};
    for (int i = 0; i < 11; i++)
    {
        printf("%c", str[i]);
    }

    printf("\n");

    char str1[15] = "Good Story!";
    for (int i = 0; i < 11; i++)
    {
        printf("%c", str[i]);
    }

    return 0;
}
```

字符数组的输入输出

输入：```scanf```、```getchar```、```gets```

输出：```printf```、```putchar```、```puts```

```scanf```和```printf```对字符类型有两种格式：
- ```%c```
- ```%s```

```%c```输入单个字符
```%s```输入字符串到字符数组中

```%c``` 识别**空格、换行**并将其输入到字符中
```%s``` 通关**空格**或**换行**来识别一个字符串的结束

```getchar```可以识别换行符，会存储换行符
和```%c```类似，对空白符比较敏感

```c++
#include <stdio.h>

int main()
{
    char str[5][5];
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            str[i][j] = getchar();
        }
        getchar(); // 把输入中每行末尾的换行符吸收掉
    }

    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            putchar(str[i][j]);
        }
        putchar('\n');
    }
    return 0;
}
```

```gets``` 和 ```puts``` 用来处理字符串

```gets```与```%s```类似，遇到换行符会认为是输入字符串的结束

若在```gets```使用之前，使用了```scanf```，那么在输入以后，会在输入流中残留换行符

在使用```gets```之前，要用```getchar```接收之前输入留下的换行符

gets会将换行符或回车替换为```\0```

```puts```的输出结果**自带换行**

```c++
#include <stdio.h>

int main()
{
    char str1[20];
    char str2[5][10];

    gets(str1);

    for (int i = 0; i < 3; i++)
    {
        gets(str2[i]);
    }

    puts(str1);
    for (int i = 0; i < 3; i++)
        puts(str2[i]);

    return 0;
}
```

一维字符数组的末尾都有一个空字符```\0```，以表示存放的字符串的结尾

在使用 ```gets``` 或 ```scanf``` 输入字符串时，```\0```会自动添加在输入的字符串后面，并占用一个字符串位

```puts``` 和 ```printf``` 在输出字符串时，会将```\0```作为字符串的结尾来输出
> 在输入的时候，会将空格或换行当作字符串的结束

在开辟字符数组时，字符数组的长度要比实际存储字符串的长度至少多1
```\0```与空格不是同一个东西，空格的ASCII码为32

如果不是使用```scanf```的```%s```格式或```gets```函数输入字符串（比如```getchar```），要在输入的每个字符串后面加上```\0```，否则```printf```和```puts```找不到字符串末尾而输出乱码


# string.h头文件

- strlen 获得字符数组第一个```\0```前的字符的个数
- strcmp 返回两个字符串大小的比较结果，按字典序比较
- strcpy 将一个字符串复制给另一个字符串，复制包括```\0```
- strcat 把一个字符串连接到另一个字符串后面

```c++
#include <stdio.h>
#include <string.h>

int main()
{
    // strlen
    char str[10];
    gets(str);
    int len = strlen(str);
    printf("%d\n", len);

    // strcmp
    char str1[50], str2[20];
    gets(str1);
    gets(str2);

    int cmp = strcmp(str1, str2);
    if (cmp < 0)
        printf("str1 < str2\n");
    else if (cmp > 0)
        printf("str1 > str2\n");
    else
        printf("str1 == str2\n");

    // strcpy
    gets(str1);
    gets(str2);
    strcpy(str1, str2);
    puts(str1);

    // strcat
    gets(str1);
    gets(str2);
    strcat(str1, str2);
    puts(str1);

    return 0;
}
```

# sscanf 与 sprintf

两个函数的头文件是```stdio.h```

